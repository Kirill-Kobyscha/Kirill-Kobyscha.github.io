<html lang="ru">
  <head>
    <meta charset="UTF-8">
    <title>Языки Пограммирования</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="background-container">
      <img class="background-image" src="background.jpg">
    </div>

    <div class="buttons-background">
      <a href="index.html" class="home-button"></a>
      <div class="buttons-container">
        <div class="button">
          <a href="1.html" class="pressed-button">Топ, изменивших мир</a>
        </div>
        <div class="button">
          <a href="2.html" class="pressed-button">Топ самых сложных</a>
        </div>
        <div class="button">
          <a href="3.html" class="pressed-button">Топ русских</a>
        </div>
        <div class="button">
          <a href="4.html" class="pressed-button">История зарождения</a>
        </div>
        <div class="button">
          <a href="5.html" class="pressed-button">Топ мёртвых</a>
        </div>
      </div>
    </div>

    <div class="first-text">
      <div id="container">
        <div id="nav"></div>
    
        <div id="aside"></div>
    
        <div id="content"></div>
          <h1>
            История зарождения
          </h1>

          <h2>
            Машинные коды и Ассемблер
          </h2>
          <p>
            Физические принципы работы электронных устройств ЭВМ таковы, что компьютер может воспринимать команды, состоящие только из единиц и нулей — последовательность перепада напряжения, то есть машинный код. На начальной стадии развития ЭВМ человеку было необходимо составлять программы на языке, понятном компьютеру, в машинных кодах. Каждая команда состояла из кода операций и адресов операндов, выраженных в виде различных сочетаний единиц и нулей. Итак, любая программа для процессора выглядела на то время как последовательность единиц и нулей.

            Как показала в дальнейшем практика общения с компьютером, такой язык громоздок и неудобен. При пользовании им легко допустить ошибку, записав не в той последовательности 1 или 0. Программу очень трудно контролировать. Кроме того, при программировании в машинных кодах надо хорошо знать внутреннюю структуру ЭВМ, принцип работы каждого блока. И самое плохое в таком языке, что программы на данном языке — очень длинные последовательности единиц и нулей являются машинно зависимыми, то есть для каждой ЭВМ необходимо было составлять свою программу, а также программирование в машинных кодах требует от программиста много времени, труда, повышенного внимания.
            
            Довольно скоро стало понятно, что процесс формирования машинного кода можно автоматизировать. Уже в 1950 году для записи программ начали применять мнемонический язык — язык assembly. Язык ассемблера позволил представить машинный код в более удобной для человека форме: для обозначения команд и объектов, над которыми эти команды выполняются, вместо двоичных кодов использовались буквы или сокращенные слова, которые отражали суть команды. Например, на языке ассемблера команда сложения двух чисел обозначается словом add, тогда как ее машинный код может быть таким: 000010.
            
            Ассемблер — язык программирования низкого уровня. Язык программирования низкого уровня — язык программирования, который ориентирован на конкретный тип процессора и учитывает его особенности. В данном случае «низкий уровень» не значит «плохой». Имеется в виду, что операторы языка близки к машинному коду и ориентированы на конкретные команды процессора. Появление языка ассемблера значительно облегчило жизнь программистов, так как теперь вместо рябящих в глазах нулей и единиц, они могли писать программу командами, состоящими из символов приближенных к обычному языку. Для того времени этот язык был новшеством и пользовался популярностью так как позволял писать программы небольшого размера, что при тех машинах критерий значительный.
            
            Но сложность разработки в нём больших программных комплексов привела к появлению языков третьего поколения — языков высокого уровня. Но на этом применение ассемблера не закончилось, он пользуется популярностью в узких кругах и по сей день. Сейчас его используют в написании отдельных фрагментов программ или иногда в написании самих программ. Примеров может быть много, но самые яркие это использование ассемблера в написании драйверов, игр и загрузчиков ОС. Не стоит забывать, что у хакеров этот язык так же пользуется популярностью, в связи с тем, что скорость работы полученной программы значительно выше скорости программы написанной на языке программирования высокого уровня. Это объясняется тем, что получившийся размер программы очень мал. Разработчики антивирусов так же используют ассемблер в некоторых модулях своих программ, что так же обеспечивает их быстродействие.
          </p>

          <h2>
            Первые языки программирования высокого уровня
          </h2>
          <p>
            Середина 50-х гг. характеризуется стремительным прогрессом в области программирования. Роль программирования в машинных кодах стала уменьшаться, стали появляться языки программирования нового типа, выступающие в роли посредника между машинами и программистами. Наступило время второго и третьего поколений языков программирования.

            С середины 50-х г. XX в. начали создавать первые языки программирования высокого уровня (high-level programming languages). Эти языки не были привязаны к определенному типу ЭВМ (машинонезависимы). Для каждого из них были разработаны собственные компиляторы. Компиляция — трансляция программы, составленной на исходном языке высокого уровня, в эквивалентную программу на низкоуровневом языке, близком машинному коду (абсолютный код, объектный модуль, иногда язык ассемблера).
          </p>

          <h2>
            Язык программирования FORTRAN
          </h2>
          <p>
            Первый язык высокого уровня Фортран был создан в период с 1954 по 1957 год группой программистов под руководством Джона Бэкуса в корпорации IBM. Он предназначался для научных и технических расчетов. Название Fortran является сокращением от FORmula TRANslator (переводчик формул).
          </p>

          <h2>
            Появление структурного программирования
          </h2>
          <p>
            К концу 1960-х годов в связи с ростом сложности программ и дальнейшим развитием программных средств возникла необходимость увеличить производительность труда программистов, что привело к разработке структурного программирования. Основоположником данной методологии считается Эдсгер Дейкстра, который в 1968 году опубликовал своё знаменитое письмо «Оператор Goto считается вредным»[10], а также описал основные принципы структурного программирования[11]. С развитием структурного программирования следующим достижением были процедуры и функции. То есть, если есть задача, которая выполняется несколько раз, то её можно объявить как функцию или как процедуру и в выполнении программы просто вызывать её. Общий код программы в данном случае становится меньше. Это способствовало созданию модульных программ.

            Следующим достижением было объединение разнородных данных, которые используются в программе в связке, в структуры.
            
            Структуры — это составные типы данных, построенные с использованием других типов данных. Например, структура времени разбивается на: часы, минуты, секунды. В свою очередь и часы, и минуты, и секунды описаны при помощи более простых и элементарных типов данных. И вместо работы с отдельными переменными, в которых легко запутаться, можно перейти к структуре «время», включающее в себя уже часы, минуты и секунды, и работать с ней, как с единым типом одного формата.
            
            Структурное программирование предполагает точно обозначенные управляющие структуры, программные блоки, отсутствие инструкций безусловного перехода (GOTO), автономные подпрограммы, поддержку рекурсии и локальных переменных. Суть такого подхода заключается в возможности разбиения программы на составляющие элементы с увеличением читабельности программного кода[12].
            
            Также создавались функциональные (аппликативные) языки (Пример: Lisp — англ. LISt Processing, 1958) и логические языки (пример: Prolog — англ. PROgramming in LOGic, 1972).
            
            Хотя внедрение структурного программирования дало положительный результат, даже оно оказывалось несостоятельным тогда, когда программа достигала определённой длины. Для того чтобы написать более сложную и длинную программу, нужен был новый подход к программированию.
          </p>
          <p class="author">
            Created by Kirill Kobyscha
          </p>
        </div>
    </div>
  </body>
</html>